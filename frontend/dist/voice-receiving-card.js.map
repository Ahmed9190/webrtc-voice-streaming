{"version":3,"file":"voice-receiving-card.js","sources":["../../frontend/src/voice-receiving-editor.ts","../../frontend/src/voice-receiving-card.ts"],"sourcesContent":["import { LitElement, html, css, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { HomeAssistant, VoiceReceivingCardConfig } from \"./types\";\n\n@customElement(\"voice-receiving-card-editor\")\nexport class VoiceReceivingCardEditor extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n  @state() private _config!: VoiceReceivingCardConfig;\n\n  public setConfig(config: VoiceReceivingCardConfig): void {\n    this._config = config;\n  }\n\n  private _valueChanged(ev: CustomEvent): void {\n    if (!this._config || !this.hass) {\n      return;\n    }\n    const target = ev.target as any;\n    if ((this as any)[`_${target.configValue}`] === target.value) {\n      return;\n    }\n    if (target.configValue) {\n      if (target.value === \"\") {\n        const newConfig = { ...this._config };\n        delete newConfig[target.configValue!];\n        this._config = newConfig;\n      } else {\n        this._config = {\n          ...this._config,\n          [target.configValue!]: target.checked !== undefined ? target.checked : target.value,\n        };\n      }\n    }\n    this.dispatchEvent(new CustomEvent(\"config-changed\", { detail: { config: this._config }, bubbles: true, composed: true }));\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <div class=\"card-config\">\n        <ha-textfield label=\"Title\" .value=${this._config.title || \"\"} .configValue=${\"title\"} @input=${this._valueChanged}></ha-textfield>\n        <ha-textfield\n          label=\"Server URL (optional)\"\n          .value=${this._config.server_url || \"\"}\n          .configValue=${\"server_url\"}\n          helper=\"Defaults to localhost:8080/ws\"\n          @input=${this._valueChanged}\n        ></ha-textfield>\n        <div class=\"side-by-side\">\n          <ha-formfield label=\"Auto Play\">\n            <ha-switch .checked=${this._config.auto_play !== false} .configValue=${\"auto_play\"} @change=${this._valueChanged}></ha-switch>\n          </ha-formfield>\n        </div>\n      </div>\n    `;\n  }\n\n  static styles = css`\n    .card-config {\n      display: flex;\n      flex-direction: column;\n      gap: 16px;\n    }\n    .side-by-side {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 16px;\n    }\n    ha-textfield {\n      width: 100%;\n    }\n    ha-formfield {\n      padding-bottom: 8px;\n    }\n  `;\n}\n","import { LitElement, html, css } from \"lit\";\nimport { customElement, property, state, query } from \"lit/decorators.js\";\nimport { VoiceReceivingCardConfig, HomeAssistant, ConnectionStatus } from \"./types\";\nimport { WebRTCManager } from \"./webrtc-manager\";\nimport { sharedStyles } from \"./styles\";\nimport \"./voice-receiving-editor\";\n\n// Constants for configuration\nconst CONSTANTS = {\n  RECONNECT: {\n    INITIAL_DELAY: 1000,\n    MAX_DELAY: 30000,\n    BACKOFF_FACTOR: 1.5,\n  },\n  TIMERS: {\n    STREAM_CHECK_INTERVAL: 5000,\n    AUTO_CONNECT_WAIT: 500,\n    UI_UPDATE_DELAY: 200,\n  },\n  AUDIO: {\n    FFT_SIZE: 256,\n  },\n  LATENCY: {\n    LOW: 50,\n    MEDIUM: 150,\n  },\n};\n\n@customElement(\"voice-receiving-card\")\nexport class VoiceReceivingCard extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n  @state() private config!: VoiceReceivingCardConfig;\n  @state() private status: ConnectionStatus = \"disconnected\";\n  @state() private errorMessage: string = \"\";\n  @state() private latency: number = 0;\n  @state() private availableStreams: string[] = [];\n  @state() private selectedStream: string | null = null;\n  @state() private isWatching: boolean = false;\n  @state() private isActive: boolean = false;\n\n  @query(\"canvas\") private canvas!: HTMLCanvasElement;\n  @query(\"audio\") private audioElement!: HTMLAudioElement;\n\n  private webrtc: WebRTCManager | null = null;\n  private animationFrame: number | null = null;\n  private watchInterval: any = null;\n\n  static get styles() {\n    return [\n      sharedStyles,\n      css`\n        .controls {\n          display: flex;\n          align-items: center;\n          justify-content: center; /* Center the main button */\n          gap: 16px;\n          margin-bottom: 16px;\n        }\n\n        .action-button {\n          width: 140px; /* Wider button for text */\n          height: 50px;\n          border-radius: 25px;\n          border: none;\n          font-size: 16px;\n          font-weight: 500;\n          cursor: pointer;\n          transition: all 0.3s ease;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          gap: 8px;\n          text-transform: uppercase;\n          letter-spacing: 0.5px;\n        }\n\n        .action-button.start {\n          background: #2196f3;\n          color: white;\n        }\n\n        .action-button.start:hover {\n          background: #1976d2;\n          box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);\n        }\n\n        .action-button.stop {\n          background: #f44336;\n          color: white;\n          animation: pulse-red 2s infinite;\n        }\n\n        .action-button.stop:hover {\n          background: #d32f2f;\n          box-shadow: 0 4px 8px rgba(244, 67, 54, 0.3);\n        }\n\n        @keyframes pulse-red {\n          0% {\n            box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4);\n          }\n          70% {\n            box-shadow: 0 0 0 10px rgba(244, 67, 54, 0);\n          }\n          100% {\n            box-shadow: 0 0 0 0 rgba(244, 67, 54, 0);\n          }\n        }\n\n        .stream-list {\n          width: 100%;\n          max-height: 150px;\n          overflow-y: auto;\n          background: rgba(0, 0, 0, 0.02);\n          border-radius: 4px;\n          margin-top: 16px;\n          border-top: 1px solid var(--divider-color);\n          padding-top: 8px;\n        }\n\n        .stream-item {\n          padding: 8px 12px;\n          cursor: pointer;\n          border-bottom: 1px solid var(--divider-color);\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n        }\n\n        .stream-item:hover {\n          background: rgba(0, 0, 0, 0.05);\n        }\n\n        .stream-item.active {\n          background: rgba(var(--primary-color-rgb, 33, 150, 243), 0.1);\n          color: var(--card-primary-color);\n          font-weight: 500;\n        }\n\n        .visualization {\n          width: 100%;\n          height: 80px;\n          background: rgba(0, 0, 0, 0.05);\n          border-radius: 8px;\n          overflow: hidden;\n          margin-bottom: 16px;\n        }\n\n        .connection-indicator {\n          display: inline-block;\n          width: 10px;\n          height: 10px;\n          border-radius: 50%;\n          margin-right: 6px;\n        }\n\n        .connection-indicator.connected {\n          background: #4caf50;\n        }\n        .connection-indicator.connecting {\n          background: #ff9800;\n          animation: blink 1s infinite;\n        }\n        .connection-indicator.disconnected {\n          background: #f44336;\n        }\n\n        @keyframes blink {\n          50% {\n            opacity: 0.5;\n          }\n        }\n\n        .latency-indicator {\n          display: inline-block;\n          padding: 2px 6px;\n          border-radius: 4px;\n          font-size: 11px;\n          font-weight: bold;\n          margin-left: 8px;\n        }\n\n        .latency-low {\n          background: #4caf50;\n          color: white;\n        }\n        .latency-medium {\n          background: #ff9800;\n          color: white;\n        }\n        .latency-high {\n          background: #f44336;\n          color: white;\n        }\n      `,\n    ];\n  }\n\n  public static async getConfigElement() {\n    return document.createElement(\"voice-receiving-card-editor\");\n  }\n\n  public static getStubConfig(): VoiceReceivingCardConfig {\n    return {\n      type: \"custom:voice-receiving-card\",\n      title: \"Voice Receiver\",\n      auto_play: true,\n    };\n  }\n\n  public setConfig(config: VoiceReceivingCardConfig): void {\n    if (!config) throw new Error(\"Invalid configuration\");\n    this.config = config;\n\n    if (this.webrtc) {\n      this.webrtc.updateConfig({\n        serverUrl: this.config.server_url,\n      });\n    }\n  }\n\n  public getCardSize(): number {\n    return 4;\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.webrtc = new WebRTCManager({\n      serverUrl: this.config?.server_url,\n    });\n\n    this.webrtc.addEventListener(\"state-changed\", (e: any) => {\n      this.status = e.detail.state;\n      if (e.detail.error) {\n        this.errorMessage = e.detail.error;\n        // If error occurs, stop watching/playing to reset UI\n        if (this.status === \"error\") {\n          this.isWatching = false;\n          this.isActive = false;\n        }\n      } else {\n        this.errorMessage = \"\";\n      }\n\n      if (this.status === \"connected\") {\n        // If we are in watch mode, request streams\n        if (this.isWatching) {\n          // We might want to send a request here if the manager supports it directly,\n          // or rely on the interval\n        }\n      }\n      this.requestUpdate();\n    });\n\n    this.webrtc.addEventListener(\"streams-changed\", (e: any) => {\n      this.availableStreams = e.detail.streams || [];\n      \n      // Auto Listen Logic:\n      if (this.isWatching && this.availableStreams.length > 0) {\n        const latestStream = this.availableStreams[this.availableStreams.length - 1];\n        \n        // Only connect if we aren't already selected this stream\n        if (this.selectedStream !== latestStream) {\n            this.selectStream(latestStream);\n        }\n      }\n    });\n\n    this.webrtc.addEventListener(\"stream-added\", (e: any) => {\n      if (!this.availableStreams.includes(e.detail.streamId)) {\n        this.availableStreams = [...this.availableStreams, e.detail.streamId];\n      }\n\n      // Aggressive Auto-Connect\n      if (this.isWatching) {\n        // Switch to new stream even if playing\n        if (this.isActive) {\n          this.stopReceiving();\n          // Small delay to ensure clean state transition if needed\n          setTimeout(() => this.selectStream(e.detail.streamId), 200);\n        } else {\n          this.selectStream(e.detail.streamId);\n        }\n      }\n    });\n\n    this.webrtc.addEventListener(\"stream-removed\", (e: any) => {\n      this.availableStreams = this.availableStreams.filter((id) => id !== e.detail.streamId);\n      if (this.selectedStream === e.detail.streamId) {\n        this.selectedStream = null;\n        this.stopReceiving();\n        // If watching, we stay in watch mode and will pick up next available or wait\n        // The stopReceiving will keeping us connected if isWatching is true\n        if (this.isWatching) {\n        }\n      }\n    });\n\n    this.webrtc.addEventListener(\"track\", (e: any) => {\n      if (this.audioElement && e.detail.stream) {\n        const stream = e.detail.stream;\n\n        // Set the stream directly - it's already a MediaStream\n        this.audioElement.srcObject = stream;\n\n        // Attempt to play\n        this.audioElement\n          .play()\n          .then(() => {\n            this.isActive = true;\n            this.startVisualization();\n          })\n          .catch((error) => {\n            console.error(\"[VoiceReceiver] ‚ùå Audio playback failed:\", error);\n            // Try to enable audio on user interaction\n            if (error.name === \"NotAllowedError\") {\n              console.warn(\"[VoiceReceiver] Autoplay blocked. User interaction required.\");\n              this.errorMessage = \"Click anywhere to enable audio\";\n            }\n          });\n      } else {\n        console.error(\"[VoiceReceiver] Track event missing audio element or stream\");\n      }\n    });\n\n    this.webrtc.addEventListener(\"audio-data\", (e: any) => {\n      if (this.status !== \"connected\") {\n        this.status = \"connected\";\n        this.errorMessage = \"\";\n        this.requestUpdate();\n      }\n      if (e.detail.timestamp) {\n        this.latency = Date.now() - e.detail.timestamp * 1000;\n      }\n    });\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.stopAll();\n    this.webrtc?.stop();\n  }\n\n  private selectStream(streamId: string) {\n    // Prevent re-connecting if we are already connected/connecting to this stream\n    if (this.selectedStream === streamId && (this.isActive || this.status === 'connecting')) return;\n\n    this.selectedStream = streamId;\n    this.webrtc?.startReceiving(streamId);\n  }\n\n    private stopReceiving() {\n      if (this.isWatching) {\n          // If watching, stop stream but keep connection open for updates\n          this.webrtc?.stopStream();\n      } else {\n          // If not watching, full stop\n          this.webrtc?.stop();\n      }\n      \n      this.stopVisualization();\n      this.isActive = false;\n      // We keep selectedStream if watching to avoid \"flicker\" re-selection logic\n      // or maybe we should clear it? \n      // If we clear it, `streams-changed` will re-select it immediately.\n      // If we don't clear it, `streams-changed` sees we have it selected.\n      \n      // For manual stop, we set isWatching=false, so streams-changed won't select.\n      // For stream switching, we call stopReceiving then selectStream(newID).\n      \n      if (!this.isWatching) {\n          this.selectedStream = null;\n      }\n    }\n  private startVisualization() {\n    if (!this.canvas || !this.webrtc) return;\n    const ctx = this.canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    const draw = () => {\n      const analyser = this.webrtc?.getAnalyser();\n      if (!analyser) {\n        this.animationFrame = requestAnimationFrame(draw);\n        return;\n      }\n\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Uint8Array(bufferLength);\n      analyser.getByteFrequencyData(dataArray);\n\n      ctx.fillStyle = \"rgba(240, 240, 240, 0.3)\"; // Slight transparency for trail effect? No, opaque.\n      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n      const barWidth = (this.canvas.width / bufferLength) * 2.5;\n      let barHeight;\n      let x = 0;\n\n      for (let i = 0; i < bufferLength; i++) {\n        barHeight = (dataArray[i] / 255) * this.canvas.height;\n        ctx.fillStyle = `hsl(${(i / bufferLength) * 360}, 100%, 50%)`;\n        ctx.fillRect(x, this.canvas.height - barHeight / 2, barWidth, barHeight);\n        x += barWidth + 1;\n      }\n\n      this.animationFrame = requestAnimationFrame(draw);\n    };\n\n    draw();\n  }\n\n  private stopVisualization() {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n\n  // Start Auto Listen Mode\n  private async startAutoListen() {\n    this.isWatching = true;\n    this.errorMessage = \"\";\n\n    // Always ensure we have a clean WebSocket connection\n    try {\n      // If not connected, start receiving (which connects WebSocket)\n      if (this.status !== \"connected\") {\n        await this.webrtc?.startReceiving();\n      } else {\n      }\n    } catch (e: any) {\n      console.error(\"[AutoListen] Connection failed:\", e);\n      this.errorMessage = e.message || \"Connection failed\";\n      this.isWatching = false;\n      this.requestUpdate();\n      return;\n    }\n\n    // Poll for available streams every 5 seconds\n    if (this.watchInterval) clearInterval(this.watchInterval);\n    this.watchInterval = setInterval(() => {\n      if (this.isWatching && this.webrtc) {\n        this.webrtc.getStreams();\n      }\n    }, CONSTANTS.TIMERS.STREAM_CHECK_INTERVAL);\n\n    // Request streams immediately (critical for detecting existing streams)\n    this.webrtc?.getStreams();\n\n    // Request again after a short delay to ensure we catch existing streams\n    setTimeout(() => {\n      if (this.isWatching && this.webrtc) {\n        this.webrtc.getStreams();\n      }\n    }, 500);\n  }\n\n  // Stop Everything\n  private stopAll() {\n    this.isWatching = false;\n    this.selectedStream = null;\n    if (this.watchInterval) {\n      clearInterval(this.watchInterval);\n      this.watchInterval = null;\n    }\n    this.stopReceiving();\n  }\n\n  private manualSelectStream(streamId: string) {\n    this.isWatching = false; // Stop auto-switching\n    this.selectStream(streamId);\n  }\n\n  private getLatencyClass() {\n    if (this.latency < CONSTANTS.LATENCY.LOW) return \"latency-low\";\n    if (this.latency < CONSTANTS.LATENCY.MEDIUM) return \"latency-medium\";\n    return \"latency-high\";\n  }\n\n  private getStatusText() {\n    if (this.isActive) return `Playing: ${this.selectedStream ? this.selectedStream.substring(0, 8) : \"Unknown\"}`;\n    if (this.isWatching) return \"Watching for streams...\";\n    return this.status;\n  }\n\n  protected render() {\n    if (!this.config) return html``;\n\n    return html`\n      <ha-card>\n        <div class=\"header\">\n          <div class=\"title\">${this.config.title || this.config.name || \"Voice Receive\"}</div>\n          <div class=\"status-badge ${this.status}\">${this.status}</div>\n        </div>\n\n        <div class=\"content\">\n          <div class=\"controls\">\n            ${this.isActive || this.isWatching\n              ? html`<button class=\"action-button stop\" @click=${this.stopAll}><span>‚èπ</span> Stop Listening</button>`\n              : html`<button class=\"action-button start\" @click=${this.startAutoListen}><span>üëÇ</span> Auto Listen</button>`}\n          </div>\n\n          <div class=\"status\">\n            <div>\n              <span class=\"connection-indicator ${this.status}\" id=\"connectionIndicator\"></span>\n              <span>${this.getStatusText()}</span>\n            </div>\n            ${this.isActive\n              ? html`\n                  <div style=\"margin-top: 4px;\">\n                    <span class=\"latency-indicator ${this.getLatencyClass()}\">Latency: ${this.latency}ms</span>\n                  </div>\n                `\n              : \"\"}\n          </div>\n\n          <div class=\"visualization\">\n            <canvas width=\"300\" height=\"80\"></canvas>\n          </div>\n\n          <div class=\"stream-list\">\n            <h3 style=\"margin: 0 0 8px 0; font-size: 14px; padding: 0 12px;\">Available Streams (${this.availableStreams.length})</h3>\n            ${this.availableStreams.length > 0\n              ? this.availableStreams.map(\n                  (streamId) => html`\n                    <div class=\"stream-item ${this.selectedStream === streamId ? \"active\" : \"\"}\" @click=${() => this.manualSelectStream(streamId)}>\n                      <span>Stream: ${streamId.substring(0, 8)}...</span>\n                      ${this.selectedStream === streamId ? html`<span>üîä Playing</span>` : \"\"}\n                    </div>\n                  `\n                )\n              : html`<div style=\"padding: 12px; font-size: 12px; color: #666;\">No streams detected</div>`}\n          </div>\n\n          <audio autoplay style=\"display: none\"></audio>\n          ${this.errorMessage ? html`<div class=\"error-message\">${this.errorMessage}</div>` : \"\"}\n        </div>\n      </ha-card>\n    `;\n  }\n}\n\n// Register\n(window as any).customCards = (window as any).customCards || [];\n(window as any).customCards.push({\n  type: \"voice-receiving-card\",\n  name: \"Voice Receiving Card\",\n  description: \"Receive voice audio via WebRTC\",\n  preview: true,\n  editor: \"voice-receiving-card-editor\",\n  version: \"1.2.0\", // Fixed URL parsing - preserves path and port\n});\n"],"names":["VoiceReceivingCardEditor","LitElement","setConfig","config","this","_config","_valueChanged","ev","hass","target","configValue","value","newConfig","undefined","checked","dispatchEvent","CustomEvent","detail","bubbles","composed","render","html","title","server_url","auto_play","styles","css","__decorate","property","attribute","prototype","state","customElement","CONSTANTS","STREAM_CHECK_INTERVAL","LOW","MEDIUM","VoiceReceivingCard","constructor","status","errorMessage","latency","availableStreams","selectedStream","isWatching","isActive","webrtc","animationFrame","watchInterval","sharedStyles","getConfigElement","document","createElement","getStubConfig","type","Error","updateConfig","serverUrl","getCardSize","connectedCallback","super","WebRTCManager","addEventListener","e","error","requestUpdate","streams","length","latestStream","selectStream","includes","streamId","stopReceiving","setTimeout","filter","id","audioElement","stream","srcObject","play","then","startVisualization","catch","console","name","warn","timestamp","Date","now","disconnectedCallback","stopAll","stop","startReceiving","stopStream","stopVisualization","canvas","ctx","getContext","draw","analyser","getAnalyser","requestAnimationFrame","bufferLength","frequencyBinCount","dataArray","Uint8Array","getByteFrequencyData","fillStyle","fillRect","width","height","barWidth","barHeight","x","i","cancelAnimationFrame","startAutoListen","message","clearInterval","setInterval","getStreams","manualSelectStream","getLatencyClass","getStatusText","substring","map","query","window","customCards","push","description","preview","editor","version"],"mappings":"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"}